/<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>SysVinit vs. SystemD</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/init.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <link href="https://use.fontawesome.com/releases/v5.0.6/css/all.css" rel="stylesheet">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement('link');
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section data-background="img/space_background.jpg" class="intro" data-transition="zoom">
            <h1>SysVinit vs. SystemD</h1>
            <h2>La petite histoire des systèmes d'initialisation</h2>
            <h4>Par</h4>
            <h5 style="font-size: 0.8em;">Paul Delafosse, Thibaut Strecker et Lucas Declercq</h5>
        </section>
        <section data-background-color="#a64d79">
            <section class="concave">
                <h1>Le système d'initialisation</h1>
            </section>
            <section>
                <h3>À quoi ça sert ?</h3>
                <img class="stretch" src="img/obama.gif">
            </section>
            <section>
                <h3>Le système d'initialisation est le logiciel qui initialise votre système lors du démarrage :</h3>
                <ul>
                    <li class="fragment">il charge les pilotes du matériel</li>
                    <li class="fragment">il active la connexion au réseau</li>
                    <li class="fragment">il lance divers services systèmes</li>
                    <li class="fragment">et enfin il charge l'environnement graphique qui vous permet d'utiliser votre
                        ordinateur
                    </li>
                </ul>
                <aside class="notes">test notes</aside>
            </section>
            <section>
                <h3>Le système d'initialisation : </h3>
                <ul>
                    <li class="fragment">
                        C'est le premier processus démarré après le démarrage du kernel.
                    </li>

                    <li class="fragment">Dans les
                        faits, ce processus prend le PID 1 sur le système.
                    </li>

                    <li class="fragment">Il est toujours lancé par le kernel de Linux,
                        après les premières étapes de boot réalisées par le BIOS et le bootloader.
                    </li>
                </ul>
            </section>
            <section class="concave">
                <p>
                    Ce processus
                    doit toujours être actif.
                    Si jamais PID 1 est interrompu on entre alors en kernel Panic !
                </p>
                <video class="fragment" data-autoplay="" loop="loop" src="img/bomb.mp4">
                </video>
            </section>
            <section>
                <p>Vous pouvez d'ailleurs essayer :</p>
                <pre class="fragment"><code>sudo kill -9 1</code></pre>
                <small class="fragment">À vos risques et périls... :)</small>
            </section>
            <section>
                <h3>Pourquoi ce processus est-il si vital ?</h3>
                <ul>
                    <li class="fragment">Un processus est toujours créé par un autre, appelé son processus père.</li>
                    <li class="fragment">Exception faite du processus initial qui est <u>le père de tous les autres
                        !</u></li>
                </ul>
            </section>
            <section>
                <video class="stretch" data-autoplay="" loop="loop" src="img/vador.mp4"></video>
            </section>
            <section>
                <p>Pour avoir un résumé de tout ce que fait le <b>PID 1</b> au démarrage :</p>
                <pre><code>$ systemd-analyse plot > boostpid.svg </code></pre>
            </section>
            <section data-background-color="white" data-background-size="contain"
                     data-background="img/pid_background.png">

            </section>
            <section>
                <h3>Les roles d'un système d'initialisation :</h3>
                <ul>
                    <li class="fragment">Il démarre le reste des processus nécessaires au lancement du système
                        d'exploitation
                    </li>
                    <li class="fragment">Il gère le cycle de vie des autres processus</li>
                    <li class="fragment">Il gère le nettoyage des processus orphelins (processus zombies)</li>
                    <li class="fragment">Il a aussi un rôle de monitoring</li>
                </ul>
            </section>
            <section>
                <h3 style="color: red;">SLIDE DE TRANSITION VERS SYSVINIT</h3>
            </section>
        </section>
        <section data-background-color="#783f04">
            <section>
                <h1>SysVinit</h1></section>
            <section>
                <h3>Un peu d'histoire ...</h3>
                <ul>
                    <li class="fragment">Init fait référence à <span style="text-transform: capitalize;">SysVInit</span>, le système d’initialisation de <span style="text-transform: capitalize;">SystemV</span>, le
                        premier
                        système d’exploitation Unix commercial.
                    </li>
                    <li class="fragment">SysV a connu 4 versions majeures depuis la première en 1983, dont la quatrième
                        (SRV4), succés majeur, à été soutenu par les principaux vendeurs de systèmes
                        Unix.
                    </li>
                </ul>
            </section>
            <section>
                <p>Init est donc un très vieux système !</p>
                <img class="stretch" src="img/oldlady.jpg">
            </section>
            <section>
                <h3>On peut découper Init en deux composants principaux :</h3>
                <ul>
                    <li class="fragment">I. Les runlevels</li>
                    <li class="fragment">II. Les scripts d'initialisation</li>
                </ul>
            </section>
            <section>
                <h3>I. Les Runlevels</h3>
                <ul>
                    <li class="fragment">Un <b>runlevel</b> est un des modes dans lequel un système Unix s'exécute.
                    </li>
                    <li class="fragment">
                        Chaque
                        <b>runlevel</b>
                        possède un
                        certain nombre de processus actifs ou stoppés.
                    </li>
                    <li class="fragment">Une fois le kernel démarré, <b>init</b> lit le fichier
                        <span style="padding-right: 10px; padding-left: 10px; background-color: #3f3f3f; font-family: monospace; font-size: 0.8em; box-shadow: 0px 0px 6px rgba(0, 0, 0, 0.3);">/etc/inittab</span>
                        pour déterminer
                        le
                        comportement de
                        chaque <b>runlevel</b> ainsi que le <b>runlevel</b> par défaut.
                    </li>
                    <aside class="notes">
                        À moins que l'utilisateur ait spécifié un paramètre spécial au démarrage, le système va essayer
                        de
                        démarrer au <b>runlevel</b> par défaut (ex : 3 pour les systèmes Red Hat)
                    </aside>
                </ul>
            </section>
            <section>
                <h3>
                    Il existe 8 runlevels :
                </h3>
                <table class="reveal">
                    <thead>
                    <tr>
                        <th>Runlevel</th>
                        <th>Mode</th>
                        <th>Actions</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>0</td>
                        <td>Halt</td>
                        <td>Éteint le système</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>Single-User Mode</td>
                        <td>Pas de réseau, de daemons ou d'autre utilisateur que root</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>Multi-User Mode</td>
                        <td>Ne configure pas le réseau ou les daemons</td>
                    </tbody>
                </table>
            </section>
            <section>
                <p>(Suite)</p>
                <table>
                    <thead>
                    <tr>
                        <th>Runlevel</th>
                        <th>Mode</th>
                        <th>Actions</th>
                    </tr>
                    </thead>
                    <tr>
                        <td>3</td>
                        <td>Multi-User Mode with Networking</td>
                        <td>Démarre le système normalement</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>Undefined</td>
                        <td>Pas utilisé</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>X11</td>
                        <td>Comme le runlevel 3 + interface graphique</td>
                    </tr>
                    <tr>
                        <td>6</td>
                        <td>Reboot</td>
                        <td>Redémarre le système</td>
                    </tr>
                </table>
            </section>
            <section>
                <h3>Comment démarrent nos applications ?</h3>
                <ul>
                <li class="fragment">Les applications démarrées par init ont leur script placé dans le dossier
                    <span class="inline-path">/etc/rc.d</span> Dans
                    ce dossier il y a un dossier pour chaque runlevel : rc0.d, rc1.d etc..</li>
                <li class="fragment">Si le système démarre par défaut au niveau 3, il faut donc que le script de notre
                    application soit
                    présent dans le dossier rc3.d.</li>
                </ul>
                <small class="fragment"><i class="fa fa-info-circle"></i> On peut aussi utiliser un lien symbolique</small>
            </section>
            <section>
                <h3>Gérer tous ces dossiers, fichiers et liens symboliques parait compliqué...</h3>
                <img style="height: 12em;" src="img/cables.jpg">
            </section>
            <section>
                <h3>Rassurez vous, on peut simplifier !</h3>
                <img src="img/baby.gif">
            </section>
            <section>
                <p>Grâce à <b>chkconfig</b> on peut visualiser l'activation des scripts pour chaque
                    <b>runlevel</b> :</p>
                <pre><code data-trim data-noescape>root@host:~ # chkconfig --list
filelimits 0:off 1:off 2:on 3:on 4:on 5:on 6:off
syslog 0:off 1:off 2:on 3:on 4:on 5:on 6:off
gpm 0:off 1:off 2:on 3:on 4:on 5:on 6:off
cpanel 0:off 1:off 2:off 3:on 4:on 5:on 6:off
kudzu 0:off 1:off 2:off 3:on 4:on 5:on 6:off
ntpd 0:off 1:off 2:off 3:off 4:off 5:off 6:off
netfs 0:off 1:off 2:off 3:on 4:on 5:on 6:off
network 0:off 1:off 2:on 3:on 4:on 5:on 6:off
netplugd 0:off 1:off 2:off 3:off 4:off 5:off 6:off
rawdevices 0:off 1:off 2:off 3:on 4:on 5:on 6:off
ipchains 0:off 1:off 2:on 3:on 4:on 5:on 6:off
iptables 0:off 1:off 2:on 3:on 4:on 5:on 6:off
crond 0:off 1:off 2:on 3:on 4:on 5:on 6:off
anacron 0:off 1:off 2:on 3:on 4:on 5:on 6:off
cups 0:off 1:off 2:on 3:on 4:on 5:on 6:off
xfs 0:off 1:off 2:on 3:on 4:on 5:on 6:off
xinetd 0:off 1:off 2:off 3:on 4:on 5:on 6:off
httpd 0:off 1:off 2:off 3:on 4:off 5:on 6:off
	            </code></pre>
                <small class="fragment"><i class="fas fa-info-circle"></i> On peut activer un script avec la commande <i>chkconfig on
                    /chemin/du/script</i></small>
            </section>
            <section>
                <h3>Pour résumer, voici ce qui se passe quand on démarre Linux :</h3>
                <ol>
                    <li class="fragment">Le BIOS ou le bootloader (lilo, grub, etc) charge le kernel, du disque vers la
                        mémoire. Le fichier du kernel reste dans le dossier <span class="inline-path">/boot</span>, il n'est lu qu'à ce moment précis.
                    </li>
                    <li class="fragment">En mémoire, le code du kernel s'exécute, et détecte divers éléments : disques,
                        partitions, etc...
                    </li>
                    <li class="fragment">Le kernel monte le système de fichier qui doit obligatoirement contenir
                        certains dossiers : <span class="inline-path">/etc</span>, <span class="inline-path">/bin</span>, <span class="inline-path">/lib</span>...
                    </li>
                </ol>
            </section>
            <section>
                <ol start="4">
                    <li>Immédiatement après, le kernel appelle la commande init (<span class="inline-path">/sbin/init</span>) et lui passe la main.</li>
                    <li class="fragment">La commande init lit le fichier <span class="inline-path">/etc/inittab</span> qui définit le runlevel du
                        système, et les scripts système à exécuter.
                    </li>
                    <li class="fragment">Ces scripts vont finir la mise en place des parties vitales du système
                        (systèmes de fichier, SWAP, mémoire virtuelle...).
                    </li>
                    <li class="fragment">Et enfin, init va lancer les scripts présents dans <span class="inline-path">/etc/rc.d</span></li>
                </ol>
            </section>
            <section>
                <h3>II. Les scripts d'initialisations</h3>
            </section>
            <section>
                <h3>Mais qu'est-ce qu'un script d'initialisation ?</h3>
                <p class="fragment">C'est un script bash !</p>
            </section>
            <section>
                <p>Voilà à quoi ça ressemble : on a un block de fonctions qui correspondent aux paramètres start et stop.</p>
<pre><code>start() {        
    echo start
    # commands to launch application
}                 

stop() {          
    echo stop
    # commands to kill application 
}

status() {
    echo "running"
    # commands to see the status of the application
}</code></pre>
            </section>
            <section>
                <p>Et un switch/case pour gérer ces fonctions côté utilisateur :</p>
                
<pre><code>case "$1" in
start)
    start
    ;;
stop)
    stop
    ;;
restart)
    stop
    start
    ;;
*)
    echo "Usage: $0 {start|stop|restart|uninstall}"
esac 
</code></pre>
            </section>
            <section>
                <h3>Le point de vue de Daniel et Daniel.</h3>
    <pre style="padding:1ch;" class="fragment"><i> - Mais Daniel, c'est tout ???</i></pre>
    <pre style="padding:1ch;" class="fragment"><i> - Et oui Daniel. C'est tout, on pourrait rajouter de la complexité 
    en gérant les PID files, les utilisateurs 
    et les logs mais le principe de base est là. 
    Si tu trouves ça simple je te conseille de jeter un oeil
    au script d'initialisation de Gitlab.</i> </pre>
            </section>
            <section>
                <h3>Exemple : le script d'init de Gitlab (500 lignes)</h3>
                <pre><code>
    #! /bin/sh

# GITLAB
# Maintainer: @randx
# Authors: rovanion.luckey@gmail.com, @randx

### BEGIN INIT INFO
# Provides:          gitlab
# Required-Start:    $local_fs $remote_fs $network $syslog redis-server
# Required-Stop:     $local_fs $remote_fs $network $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: GitLab git repository management
# Description:       GitLab git repository management
# chkconfig: - 85 14
### END INIT INFO


###
# DO NOT EDIT THIS FILE!
# This file will be overwritten on update.
# Instead add/change your variables in /etc/default/gitlab
# An example defaults file can be found in lib/support/init.d/gitlab.default.example
###


### Environment variables
RAILS_ENV="production"

# Script variable names should be lower-case not to conflict with
# internal /bin/sh variables such as PATH, EDITOR or SHELL.
app_user="git"
app_root="/home/$app_user/gitlab"
pid_path="$app_root/tmp/pids"
socket_path="$app_root/tmp/sockets"
rails_socket="$socket_path/gitlab.socket"
web_server_pid_path="$pid_path/unicorn.pid"
sidekiq_pid_path="$pid_path/sidekiq.pid"
mail_room_enabled=false
mail_room_pid_path="$pid_path/mail_room.pid"
gitlab_workhorse_dir=$(cd $app_root/../gitlab-workhorse 2> /dev/null && pwd)
gitlab_workhorse_pid_path="$pid_path/gitlab-workhorse.pid"
gitlab_workhorse_options="-listenUmask 0 -listenNetwork unix -listenAddr $socket_path/gitlab-workhorse.socket -authBackend http://127.0.0.1:8080 -authSocket $rails_socket -documentRoot $app_root/public"
gitlab_workhorse_log="$app_root/log/gitlab-workhorse.log"
gitlab_pages_enabled=false
gitlab_pages_dir=$(cd $app_root/../gitlab-pages 2> /dev/null && pwd)
gitlab_pages_pid_path="$pid_path/gitlab-pages.pid"
gitlab_pages_options="-pages-domain example.com -pages-root $app_root/shared/pages -listen-proxy 127.0.0.1:8090"
gitlab_pages_log="$app_root/log/gitlab-pages.log"
shell_path="/bin/bash"
gitaly_enabled=true
gitaly_dir=$(cd $app_root/../gitaly 2> /dev/null && pwd)
gitaly_pid_path="$pid_path/gitaly.pid"
gitaly_log="$app_root/log/gitaly.log"

# Read configuration variable file if it is present
test -f /etc/default/gitlab && . /etc/default/gitlab

# Switch to the app_user if it is not he/she who is running the script.
if [ `whoami` != "$app_user" ]; then
  eval su - "$app_user" -c $(echo \")$shell_path -l -c \'$0 "$@"\'$(echo \"); exit;
fi

# Switch to the gitlab path, exit on failure.
if ! cd "$app_root" ; then
 echo "Failed to cd into $app_root, exiting!";  exit 1
fi


### Init Script functions

## Gets the pids from the files
check_pids(){
  if ! mkdir -p "$pid_path"; then
    echo "Could not create the path $pid_path needed to store the pids."
    exit 1
  fi
  # If there exists a file which should hold the value of the Unicorn pid: read it.
  if [ -f "$web_server_pid_path" ]; then
    wpid=$(cat "$web_server_pid_path")
  else
    wpid=0
  fi
  if [ -f "$sidekiq_pid_path" ]; then
    spid=$(cat "$sidekiq_pid_path")
  else
    spid=0
  fi
  if [ -f "$gitlab_workhorse_pid_path" ]; then
    hpid=$(cat "$gitlab_workhorse_pid_path")
  else
    hpid=0
  fi
  if [ "$mail_room_enabled" = true ]; then
    if [ -f "$mail_room_pid_path" ]; then
      mpid=$(cat "$mail_room_pid_path")
    else
      mpid=0
    fi
  fi
  if [ "$gitlab_pages_enabled" = true ]; then
    if [ -f "$gitlab_pages_pid_path" ]; then
      gppid=$(cat "$gitlab_pages_pid_path")
    else
      gppid=0
    fi
  fi
  if [ "$gitaly_enabled" = true ]; then
    if [ -f "$gitaly_pid_path" ]; then
      gapid=$(cat "$gitaly_pid_path")
    else
      gapid=0
    fi
  fi
}

## Called when we have started the two processes and are waiting for their pid files.
wait_for_pids(){
  # We are sleeping a bit here mostly because sidekiq is slow at writing its pid
  i=0;
  while [ ! -f $web_server_pid_path ] || [ ! -f $sidekiq_pid_path ] || [ ! -f $gitlab_workhorse_pid_path ] || { [ "$mail_room_enabled" = true ] && [ ! -f $mail_room_pid_path ]; } || { [ "$gitlab_pages_enabled" = true ] && [ ! -f $gitlab_pages_pid_path ]; } || { [ "$gitaly_enabled" = true ] && [ ! -f $gitaly_pid_path ]; }; do
    sleep 0.1;
    i=$((i+1))
    if [ $((i%10)) = 0 ]; then
      echo -n "."
    elif [ $((i)) = 301 ]; then
      echo "Waited 30s for the processes to write their pids, something probably went wrong."
      exit 1;
    fi
  done
  echo
}

# We use the pids in so many parts of the script it makes sense to always check them.
# Only after start() is run should the pids change. Sidekiq sets its own pid.
check_pids


## Checks whether the different parts of the service are already running or not.
check_status(){
  check_pids
  # If the web server is running kill -0 $wpid returns true, or rather 0.
  # Checks of *_status should only check for == 0 or != 0, never anything else.
  if [ $wpid -ne 0 ]; then
    kill -0 "$wpid" 2>/dev/null
    web_status="$?"
  else
    web_status="-1"
  fi
  if [ $spid -ne 0 ]; then
    kill -0 "$spid" 2>/dev/null
    sidekiq_status="$?"
  else
    sidekiq_status="-1"
  fi
  if [ $hpid -ne 0 ]; then
    kill -0 "$hpid" 2>/dev/null
    gitlab_workhorse_status="$?"
  else
    gitlab_workhorse_status="-1"
  fi
  if [ "$mail_room_enabled" = true ]; then
    if [ $mpid -ne 0 ]; then
      kill -0 "$mpid" 2>/dev/null
      mail_room_status="$?"
    else
      mail_room_status="-1"
    fi
  fi
  if [ "$gitlab_pages_enabled" = true ]; then
    if [ $gppid -ne 0 ]; then
      kill -0 "$gppid" 2>/dev/null
      gitlab_pages_status="$?"
    else
      gitlab_pages_status="-1"
    fi
  fi
  if [ "$gitaly_enabled" = true ]; then
    if [ $gapid -ne 0 ]; then
      kill -0 "$gapid" 2>/dev/null
      gitaly_status="$?"
    else
      gitaly_status="-1"
    fi
  fi
  if [ $web_status = 0 ] && [ $sidekiq_status = 0 ] && [ $gitlab_workhorse_status = 0 ] && { [ "$mail_room_enabled" != true ] || [ $mail_room_status = 0 ]; } && { [ "$gitlab_pages_enabled" != true ] || [ $gitlab_pages_status = 0 ]; } && { [ "$gitaly_enabled" != true ] || [ $gitaly_status = 0 ]; }; then
    gitlab_status=0
  else
    # http://refspecs.linuxbase.org/LSB_4.1.0/LSB-Core-generic/LSB-Core-generic/iniscrptact.html
    # code 3 means 'program is not running'
    gitlab_status=3
  fi
}

## Check for stale pids and remove them if necessary.
check_stale_pids(){
  check_status
  # If there is a pid it is something else than 0, the service is running if
  # *_status is == 0.
  if [ "$wpid" != "0" ] && [ "$web_status" != "0" ]; then
    echo "Removing stale Unicorn web server pid. This is most likely caused by the web server crashing the last time it ran."
    if ! rm "$web_server_pid_path"; then
      echo "Unable to remove stale pid, exiting."
      exit 1
    fi
  fi
  if [ "$spid" != "0" ] && [ "$sidekiq_status" != "0" ]; then
    echo "Removing stale Sidekiq job dispatcher pid. This is most likely caused by Sidekiq crashing the last time it ran."
    if ! rm "$sidekiq_pid_path"; then
      echo "Unable to remove stale pid, exiting"
      exit 1
    fi
  fi
  if [ "$hpid" != "0" ] && [ "$gitlab_workhorse_status" != "0" ]; then
    echo "Removing stale GitLab Workhorse pid. This is most likely caused by GitLab Workhorse crashing the last time it ran."
    if ! rm "$gitlab_workhorse_pid_path"; then
      echo "Unable to remove stale pid, exiting"
      exit 1
    fi
  fi
  if [ "$mail_room_enabled" = true ] && [ "$mpid" != "0" ] && [ "$mail_room_status" != "0" ]; then
    echo "Removing stale MailRoom job dispatcher pid. This is most likely caused by MailRoom crashing the last time it ran."
    if ! rm "$mail_room_pid_path"; then
      echo "Unable to remove stale pid, exiting"
      exit 1
    fi
  fi
  if [ "$gitlab_pages_enabled" = true ] && [ "$gppid" != "0" ] && [ "$gitlab_pages_status" != "0" ]; then
    echo "Removing stale GitLab Pages job dispatcher pid. This is most likely caused by GitLab Pages crashing the last time it ran."
    if ! rm "$gitlab_pages_pid_path"; then
      echo "Unable to remove stale pid, exiting"
      exit 1
    fi
  fi
  if [ "$gitaly_enabled" = true ] && [ "$gapid" != "0" ] && [ "$gitaly_status" != "0" ]; then
    echo "Removing stale Gitaly pid. This is most likely caused by Gitaly crashing the last time it ran."
    if ! rm "$gitaly_pid_path"; then
      echo "Unable to remove stale pid, exiting"
      exit 1
    fi
  fi
}

## If no parts of the service is running, bail out.
exit_if_not_running(){
  check_stale_pids
  if [ "$web_status" != "0" ] && [ "$sidekiq_status" != "0" ] && [ "$gitlab_workhorse_status" != "0" ] && { [ "$mail_room_enabled" != true ] || [ "$mail_room_status" != "0" ]; } && { [ "$gitlab_pages_enabled" != true ] || [ "$gitlab_pages_status" != "0" ]; } && { [ "$gitaly_enabled" != true ] || [ "$gitaly_status" != "0" ]; }; then
    echo "GitLab is not running."
    exit
  fi
}

## Starts Unicorn and Sidekiq if they're not running.
start_gitlab() {
  check_stale_pids

  if [ "$web_status" != "0" ]; then
    echo "Starting GitLab Unicorn"
  fi
  if [ "$sidekiq_status" != "0" ]; then
    echo "Starting GitLab Sidekiq"
  fi
  if [ "$gitlab_workhorse_status" != "0" ]; then
    echo "Starting GitLab Workhorse"
  fi
  if [ "$mail_room_enabled" = true ] && [ "$mail_room_status" != "0" ]; then
    echo "Starting GitLab MailRoom"
  fi
  if [ "$gitlab_pages_enabled" = true ] && [ "$gitlab_pages_status" != "0" ]; then
    echo "Starting GitLab Pages"
  fi
  if [ "$gitaly_enabled" = true ] && [ "$gitaly_status" != "0" ]; then
    echo "Starting Gitaly"
  fi

  # Then check if the service is running. If it is: don't start again.
  if [ "$web_status" = "0" ]; then
    echo "The Unicorn web server already running with pid $wpid, not restarting."
  else
    # Remove old socket if it exists
    rm -f "$rails_socket" 2>/dev/null
    # Start the web server
    RAILS_ENV=$RAILS_ENV bin/web start
  fi

  # If sidekiq is already running, don't start it again.
  if [ "$sidekiq_status" = "0" ]; then
    echo "The Sidekiq job dispatcher is already running with pid $spid, not restarting"
  else
    RAILS_ENV=$RAILS_ENV bin/background_jobs start &
  fi

  if [ "$gitlab_workhorse_status" = "0" ]; then
    echo "The GitLab Workhorse is already running with pid $hpid, not restarting"
  else
    # No need to remove a socket, gitlab-workhorse does this itself.
    # Because gitlab-workhorse has multiple executables we need to fix
    # the PATH.
    $app_root/bin/daemon_with_pidfile $gitlab_workhorse_pid_path  \
      /usr/bin/env PATH=$gitlab_workhorse_dir:$PATH \
        gitlab-workhorse $gitlab_workhorse_options \
      >> $gitlab_workhorse_log 2>&1 &
  fi

  if [ "$mail_room_enabled" = true ]; then
    # If MailRoom is already running, don't start it again.
    if [ "$mail_room_status" = "0" ]; then
      echo "The MailRoom email processor is already running with pid $mpid, not restarting"
    else
      RAILS_ENV=$RAILS_ENV bin/mail_room start &
    fi
  fi

  if [ "$gitlab_pages_enabled" = true ]; then
    if [ "$gitlab_pages_status" = "0" ]; then
      echo "The GitLab Pages is already running with pid $gppid, not restarting"
    else
      $app_root/bin/daemon_with_pidfile $gitlab_pages_pid_path  \
          $gitlab_pages_dir/gitlab-pages $gitlab_pages_options \
        >> $gitlab_pages_log 2>&1 &
    fi
  fi

  if [ "$gitaly_enabled" = true ]; then
    if [ "$gitaly_status" = "0" ]; then
      echo "Gitaly is already running with pid $gapid, not restarting"
    else
      $app_root/bin/daemon_with_pidfile $gitaly_pid_path \
          $gitaly_dir/gitaly $gitaly_dir/config.toml >> $gitaly_log 2>&1 &
    fi
  fi

  # Wait for the pids to be planted
  wait_for_pids
  # Finally check the status to tell wether or not GitLab is running
  print_status
}

## Asks Unicorn, Sidekiq and MailRoom if they would be so kind as to stop, if not kills them.
stop_gitlab() {
  exit_if_not_running

  if [ "$web_status" = "0" ]; then
    echo "Shutting down GitLab Unicorn"
    RAILS_ENV=$RAILS_ENV bin/web stop
  fi
  if [ "$sidekiq_status" = "0" ]; then
    echo "Shutting down GitLab Sidekiq"
    RAILS_ENV=$RAILS_ENV bin/background_jobs stop
  fi
  if [ "$gitlab_workhorse_status" = "0" ]; then
    echo "Shutting down GitLab Workhorse"
    kill -- $(cat $gitlab_workhorse_pid_path)
  fi
  if [ "$mail_room_enabled" = true ] && [ "$mail_room_status" = "0" ]; then
    echo "Shutting down GitLab MailRoom"
    RAILS_ENV=$RAILS_ENV bin/mail_room stop
  fi
  if [ "$gitlab_pages_status" = "0" ]; then
    echo "Shutting down gitlab-pages"
    kill -- $(cat $gitlab_pages_pid_path)
  fi
  if [ "$gitaly_status" = "0" ]; then
    echo "Shutting down Gitaly"
    kill -- $(cat $gitaly_pid_path)
  fi

  # If something needs to be stopped, lets wait for it to stop. Never use SIGKILL in a script.
  while [ "$web_status" = "0" ] || [ "$sidekiq_status" = "0" ] || [ "$gitlab_workhorse_status" = "0" ] || { [ "$mail_room_enabled" = true ] && [ "$mail_room_status" = "0" ]; } || { [ "$gitlab_pages_enabled" = true ] && [ "$gitlab_pages_status" = "0" ]; } || { [ "$gitaly_enabled" = true ] && [ "$gitaly_status" = "0" ]; }; do
    sleep 1
    check_status
    printf "."
    if [ "$web_status" != "0" ] && [ "$sidekiq_status" != "0" ] && [ "$gitlab_workhorse_status" != "0" ] && { [ "$mail_room_enabled" != true ] || [ "$mail_room_status" != "0" ]; } && { [ "$gitlab_pages_enabled" != true ] || [ "$gitlab_pages_status" != "0" ]; } && { [ "$gitaly_enabled" != true ] || [ "$gitaly_status" != "0" ]; }; then
      printf "\n"
      break
    fi
  done

  sleep 1
  # Cleaning up unused pids
  rm "$web_server_pid_path" 2>/dev/null
  # rm "$sidekiq_pid_path" 2>/dev/null # Sidekiq seems to be cleaning up its own pid.
  rm -f "$gitlab_workhorse_pid_path"
  if [ "$mail_room_enabled" = true ]; then
    rm "$mail_room_pid_path" 2>/dev/null
  fi
  rm -f "$gitlab_pages_pid_path"
  rm -f "$gitaly_pid_path"

  print_status
}

## Prints the status of GitLab and its components.
print_status() {
  check_status
  if [ "$web_status" != "0" ] && [ "$sidekiq_status" != "0" ] && [ "$gitlab_workhorse_status" != "0" ] && { [ "$mail_room_enabled" != true ] || [ "$mail_room_status" != "0" ]; } && { [ "$gitlab_pages_enabled" != true ] || [ "$gitlab_pages_status" != "0" ]; } && { [ "$gitaly_enabled" != true ] || [ "$gitaly_status" != "0" ]; }; then
    echo "GitLab is not running."
    return
  fi
  if [ "$web_status" = "0" ]; then
      echo "The GitLab Unicorn web server with pid $wpid is running."
  else
      printf "The GitLab Unicorn web server is \033[31mnot running\033[0m.\n"
  fi
  if [ "$sidekiq_status" = "0" ]; then
      echo "The GitLab Sidekiq job dispatcher with pid $spid is running."
  else
      printf "The GitLab Sidekiq job dispatcher is \033[31mnot running\033[0m.\n"
  fi
  if [ "$gitlab_workhorse_status" = "0" ]; then
      echo "The GitLab Workhorse with pid $hpid is running."
  else
      printf "The GitLab Workhorse is \033[31mnot running\033[0m.\n"
  fi
  if [ "$mail_room_enabled" = true ]; then
    if [ "$mail_room_status" = "0" ]; then
        echo "The GitLab MailRoom email processor with pid $mpid is running."
    else
        printf "The GitLab MailRoom email processor is \033[31mnot running\033[0m.\n"
    fi
  fi
  if [ "$gitlab_pages_enabled" = true ]; then
    if [ "$gitlab_pages_status" = "0" ]; then
        echo "The GitLab Pages with pid $gppid is running."
    else
        printf "The GitLab Pages is \033[31mnot running\033[0m.\n"
    fi
  fi
  if [ "$gitaly_enabled" = true ]; then
    if [ "$gitaly_status" = "0" ]; then
        echo "Gitaly with pid $gapid is running."
    else
        printf "Gitaly is \033[31mnot running\033[0m.\n"
    fi
  fi
  if [ "$web_status" = "0" ] && [ "$sidekiq_status" = "0" ] && [ "$gitlab_workhorse_status" = "0" ] && { [ "$mail_room_enabled" != true ] || [ "$mail_room_status" = "0" ]; } && { [ "$gitlab_pages_enabled" != true ] || [ "$gitlab_pages_status" = "0" ]; } && { [ "$gitaly_enabled" != true ] || [ "$gitaly_status" = "0" ]; }; then
    printf "GitLab and all its components are \033[32mup and running\033[0m.\n"
  fi
}

## Tells unicorn to reload its config and Sidekiq to restart
reload_gitlab(){
  exit_if_not_running
  if [ "$wpid" = "0" ];then
    echo "The GitLab Unicorn Web server is not running thus its configuration can't be reloaded."
    exit 1
  fi
  printf "Reloading GitLab Unicorn configuration... "
  RAILS_ENV=$RAILS_ENV bin/web reload
  echo "Done."

  echo "Restarting GitLab Sidekiq since it isn't capable of reloading its config..."
  RAILS_ENV=$RAILS_ENV bin/background_jobs restart

  if [ "$mail_room_enabled" != true ]; then
    echo "Restarting GitLab MailRoom since it isn't capable of reloading its config..."
    RAILS_ENV=$RAILS_ENV bin/mail_room restart
  fi

  wait_for_pids
  print_status
}

## Restarts Sidekiq and Unicorn.
restart_gitlab(){
  check_status
  if [ "$web_status" = "0" ] || [ "$sidekiq_status" = "0" ] || [ "$gitlab_workhorse" = "0" ] || { [ "$mail_room_enabled" = true ] && [ "$mail_room_status" = "0" ]; } || { [ "$gitlab_pages_enabled" = true ] && [ "$gitlab_pages_status" = "0" ]; } || { [ "$gitaly_enabled" = true ] && [ "$gitaly_status" = "0" ]; }; then
    stop_gitlab
  fi
  start_gitlab
}


### Finally the input handling.

case "$1" in
  start)
        start_gitlab
        ;;
  stop)
        stop_gitlab
        ;;
  restart)
        restart_gitlab
        ;;
  reload|force-reload)
	reload_gitlab
        ;;
  status)
        print_status
        exit $gitlab_status
        ;;
  *)
        echo "Usage: service gitlab {start|stop|restart|reload|status}"
        exit 1
        ;;
esac

exit
                </code></pre>
                <small><a href="https://github.com/gitlabhq/gitlabhq/blob/master/lib/support/init.d/gitlab">https://github.com/gitlabhq/gitlabhq/blob/master/lib/support/init.d/gitlab</a>
                </small>
            </section>
            <section>
                <h3>On peut déja voir plusieurs problèmes potentiels :</h3>
                <dl>
                    <dt class="fragment">La complexité :</dt>
                    <dd class="fragment"> un très gros projet (comme Gitlab) avec beaucoup de dépendances et de modules
                        entrainera un script d'init très complexe et indigeste.
                    </dd>
                    <dt class="fragment">L'absence de norme :</dt>
                    <dd class="fragment">chaque développeur à sa manière de programmer. Reprendre le script d'un autre
                        développeur entrainera une phase de compréhension plus ou moins longue.
                    </dd>
                </dl>
            </section>
            <section>
                <h3>Autre problème majeur d'Init :</h3>
                <p class="fragment">Il démarre les processus les uns après les autres, en attendant que le lancement
                    soit terminé avant de passer au suivant.</p>
                <video class="fragment" data-autoplay="" loop="loop" src="img/queue.mp4"></video>
            </section>
            <section>
                <p>Quand le lancement d'un processus est ralenti (par exemple à cause d'un disque dur ancien et lent)
                    cela entraine un très lent temps de démarrage du système d'exploitation.</p>
                <small class="fragment"><i class="fas fa-info-circle"></i> On peut toutefois améliorer ce temps de démarrage en utilisant un SSD comme
                    disque dur.
                </small>
            </section>
            <section>
                <h3 style="color: red;">SLIDE DE TRANSITION VERS SYSTEMD</h3>
            </section>
        </section>
        <section data-background-color="#3d85c6">

            <section>
                <h1>SystemD</h1>
            </section>
            <section>
                <img class="stretch" src="img/systemd_gandalf.jpg">
            </section>
            <section>
                <h3>Définition :</h3>
                <ul>
                    <li class="fragment">SystemD est un système d’initialisation et un daemon qui a été spécifiquement
                        conçu pour le noyau Linux comme alternative à System V. Il a été écrit en C.
                    </li>

                    <li class="fragment">Il a pour but d'offrir un
                        meilleur cadre pour la gestion des dépendances entre services, de permettre le chargement
                        en parallèle des services au démarrage, et de réduire les appels aux scripts shell.
                    </li>
                </ul>
            </section>
            <section>
                <h3>Une naissance mouvementée :</h3>
                <p class="fragment">
                    <b>SystemD</b> a été créé en 2010 par <a style="color: white;" href="https://en.wikipedia.org/wiki/Lennart_Poettering"><i>Lennart Poettering</i></a> et Kay Sievers,
                    et a été à l’origine d’intenses débats au sein de la communauté Linux.
                </p>
                <pre class="fragment" style="padding: 10px; background: #1a6091">
"I don't actually have any particularly strong opinions on systemd
itself. I've had issues with some of the core developers that
I think are much too cavalier about bugs and compatibility, and
I think some of the design details are insane (I dislike the
binary logs, for example), but those are details, not big issues."

                                      Linus Torvalds
</pre>
            </section>
            <section>
                <h3>Le principal reproche émis à l'encontre de SystemD est qu'il enfreint la philosophie Unix ::</h3>
                <pre class="fragment" style="padding: 10px; background: #1a6091">
"Write programs that do one thing and do it well. Write programs
to work together. Write programs to handle text streams, because
that isa universal interface."

                                 Douglas McLlroy</pre>
            </section>
            <section>
                <p>Bien que les projets open source soient habitués aux discussions et débats enflammés, celui-ci a
                atteint des sommets.</p>
                <p>Un des évènements les plus marquants de cette véritable guerre est l'intense débat mené entre octobre 2013
                et février 2014 au sein de la communauté Debian, ayant pour objet le choix de l'init par défaut à implémenter
                dans la version 8 "Jessie" de Debian.</p>
            </section>
            <section>
                <p>SystemD sera finalement choisi, ce qui aura pour conséquence le départs de plusieurs contributeurs vétérans ,
                    qui réaliseront un fork de Debian appelé Devuan.</p>
                <video class="fragment" style="height: 11em;" data-autoplay="" loop="loop"
                       src="img/war.mp4"></video>
            </section>
            <section>
                <h3>Les particularités de systemd :</h3>
                <ul>
                    <li class="fragment">I. Le principe KISS</li>
                    <li class="fragment">II. Un système orienté configuration</li>
                    <li class="fragment">III. La parallélisation</li>
                    <li class="fragment">IV. Les "control groups"</li>
                    <li class="fragment">V. "The Journal"</li>
                    <li class="fragment">VI. Les Timers</li>
                    <li class="fragment">VII. La galaxie <b>SystemD</b></li>
                </ul>
            </section>
            <section>
                <h3>I. Le principe KISS</h3>
                <i>"Keep It Simple Stupid"</i>
                <div style="width: 100%; align-content: center">
                    <img src="images/retarded.gif">
                </div>
            </section>
            <section>
                <h3>Stupide ? Au contraire !</h3>
                <ul>
                    <li class="fragment">Le principe <b>KISS</b> est habituellement associé à des systemes qui peuvent
                        paraitre stupide à cause de leur conception simple.
                    </li>
                    <li class="fragment">Ce principe est une règle de conception qui établie qu'un système est plus
                        performant quand il a un design simple plutôt
                        que complexe.
                    </li>
                    <li class="fragment">Ce principe a été inventé dans les années 60 par Kelly Johnson, un ingénieur
                    qui travaillait chez Lockheed Martin.</li>
                </ul>
                <aside class="notes">
                    <p>Selon Eric Raymond (aka ESR), célèbre hacker américain ayant popularisé le terme "open source", la
                        philosophie de Unix se résume à ce principe.</p>
                    <p>Pour un système d'exploitation de ce type, un shell propose une grande quantité de petits utilitaires
                        ayant des fonctions simples (ls, grep, cd, find...) avec un moyen simple de les combiner, le pipe (|).</p>
                </aside>
            </section>
            <section>
                <pre style="padding: 10px; background: #1a6091;">
"Everything should be made as simple as possible, but not simpler.
 This means that one should simplify the design of a product and
 success is achieved when a design is at its maximum simplicity."

                                              Albert Einstein
                </pre>
                <video class="fragment" style="height: 11em;" data-autoplay="" loop="loop"
                       src="img/einstein.mp4"></video>
            </section>
            <section>
                <h3>II. Un système orienté Configuration</h3>
                <ul>
                <li class="fragment">A l'inverse de SysV, SystemD implémente de nombreux outils pour décourager
                l'utisation de script de lancement.<p>
                <li class="fragment">Dans la pratique, un service géré par SystemD sera généralement configuré par un fichier d'une
                dizaine de lignes.</li>
                </ul>
                <img class="fragment" style="height: 5em;" src="img/amazing.gif">
            </section>
            <section>
                <small>La syntaxe des fichiers de
                    configuration <b>systemd</b>
                    est inspirée des standards du X Desktop
                    Group qui eux même s'inspirent
                    des fichiers Microsoft .ini
                </small>
                <pre class="stretch"><code>
#####################################################
#
# GitLab version    : 5.x - 7.x
# Contributors      : davispuh, mtorromeo, axilleas, boeserwolf91, Stefan Tatschner (rumpelsepp)
# Downloaded from   : https://gitlab.com/gitlab-org/gitlab-recipes/tree/master/init/systemd
#
####################################################

[Unit]
Description=GitLab Unicorn Server
Requires=redis.service
Wants=mysqld.service postgresql.service
After=redis.service mysqld.service postgresql.service

[Service]
User=git
WorkingDirectory=/home/git/gitlab
Environment=RAILS_ENV=production
SyslogIdentifier=gitlab-unicorn
PIDFile=/home/git/gitlab/tmp/pids/unicorn.pid

ExecStart=/usr/bin/bundle exec "unicorn_rails -D -c /home/git/gitlab/config/unicorn.rb -E production"

[Install]
WantedBy=multi-user.target</code></pre>
                <small>Exemple : le fichier de configuration de Gitlab (à comparer aux 500 lignes du script ini)</small>
            </section>
            <section>
                <h3>III. La Parallélisation</h3>
                <p>
                    Un des gros avantage de systemD sur init, c'est
                    sa capacité à lancer des processus en parallèle
                    <i>via</i> des sockets et D-bus.
                </p>
                 <!--FIXME: Mieux expliquer tout ce bouzin-->
                <p>
                    Socket et D-bus sont deux ensembles normalisés
                    de fonctions qui permettent au processus de
                    parager des données et d'échanger des messages
                </p>
            </section>
            <section>
                <h3>IV. Contrôle tes logs!</h3>
                <ul>
                <li class="fragment">
                    Dans systemd, les logs sont associés à un groupe afin de réduire les chances
                    de corruption lors d'un piratage.</li>
                <li class="fragment">Ils sont portables,
                    et l'outil comporte une gestion de saturation de l'espace.
                </li>
                <li class="fragment">
                    Tout service géré par systemd est automatiquement logué
                    dans la base de donnée de journald, à laquelle on accède via la commande journalctl.
                </li>
                </ul>
            </section>
            <section>
                <h3>V. Les Control Groups</h3>
                <ul>
                    <li class="fragment"> Systemd utilise le module cgroup du kernel linux pour organiser les processus.</li> <li class="fragment">Il permet de contrôler et de surveiller l'usage des ressources
                    physiques du système pour un ensemble de PID. <li class="fragment">Par exemple, les cgroups permettent de limiter l'usage mémoire pour un conteneur ou une VM.</li> <li class="fragment">Les ressources physiques sont allouées à des groupes de contrôle : blkio, cpu, devices, memory...etc. <small>(cf. <a style="color: deeppink;" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/ch01#sec-How_Control_Groups_Are_Organized">Documentation de Red Hat</a>)</small>
                                                          </li>
                </ul>
                
                <aside class="note">
                    Initié par des ingénieurs de Google (Paul Menage et Rohit Seth) en 2006 sous le nom « conteneur de processus».
                    <ul>
                        <li>
                            Priorisation 
                        </li>
                       <li>
                            Initié par des ingénieurs de Google (d'abord Paul Menage et Rohit Seth) en 2006 sous le nom « conteneur de processus».
                       </li> 
                       <li>
                            Isolation
                       </li>
                       <li>
                            Contrôle : figer les groupes ou créer un point de sauvegarde et redémarrer
                       </li>
                    </ul>
                    <p>Un groupe  contrôle = groupe de processus qui sont liés par le même critère. 
                        ,organisés hiérarchiquement, chaque groupe hérite des limites de son groupe parent. 
                        Le noyau fournit l'accès à plusieurs contrôleurs (sous-systèmes) à travers l'interface cgroup
                    </p>

            </section>
            <section><code>$ ps xawf -eo pid,user,cgroup,args</code></pre>
                <img src="img/cgroup_schema.png">
            </section>
            <section>

                <h3>VI. Les Timers</h3>
                <ul>
                <li class="fragment">Un Timer est un fichier (se terminant par .timer) permettant de contrôler un service comme un fichier de configuration systemd classique</li>
                <li class="fragment">Il permet de déclencher un service à un moment précis dans le temps</li>
                </ul>
                <video style="height: 8em;" class="fragment" style="height: 11em;" data-autoplay="" loop="loop"
                       src="img/hurry.mp4"></video>
            </section>
            <section>
                <h3>Principe général :</h3>
                <p>C'est un fichier spécifique à systemd, qui est obligatoirement associé à un service existant.<br>
                    Par défaut, un timer est associé au service ayant le même nom que lui.</p>
                <p>Ex : foo.timer est associé a foo.service.</p>
            </section>
            <section>
                <h3>Les timers sont divisés en deux catégories :</h3>
                <ul>
                    <li class="fragment">Les timers <i>monotones</i> (monotonic timer), qui s'activent après un temps donné.
                        Ils s'arrêtent si le système est arrêté.</li>
                    <li class="fragment">Les timers de type <i>temps-réel</i> (realtime timer), qui s'activent à un instant donné,
                    comme le font les cronjobs.</li>
                </ul>
            </section>
            <section>
                <h3>Exemple d'un timer monotone</h3>
                <pre><code>[Unit]
Description=Run foo weekly and on boot

[Timer]
OnBootSec=15min
OnUnitActiveSec=1w

[Install]
WantedBy=timers.target</code></pre>
                <p>Ici, le timer se lance 15 minutes après le démarrage du système, ainsi que toutes les semaines tant que
                    le système est actif.</p>
            </section>
            <section>
                <h3>Exemple d'un timer type temps réel.</h3>
                <pre><code>[Unit]
Description=Run foo weekly

[Timer]
OnCalendar=weekly
Persistent=true

[Install]
WantedBy=timers.target</code></pre>
                <p>Le timer se lance chaque lundi à minuit. Quand il est activé, il déclenche immédiatemment le service
                si ce dernier a manqué le dernier démarrage (par exemple si le système était éteint).</p>
            </section>
            <section>
                <h3>Les timers en remplacement de CRON</h3>
                <p>Les timers se posent en alternative solide à CRON, les bénéfices sont multiples : </p>
                <ul>
                    <li>Les <i>jobs</i> peuvent être simplement lancés indépendement de leur timers, facilitant la maintenance.</li>
                    <li>Chaque <i>job</i> peut être configuré pour fonctionner dans un environnement spécifique.</li>
                    <li>Ils peuvent être liés à des cgroups.</li>
                    <li>Ils peuvent être liés à d'autres units de systemd.</li>
                    <li>Les jobs sont logués dans le journal de systemd.</li>
                </ul>
            </section>
            <section>
                <h3>VII. SystemD Galaxy</h3>
                <p>systemd-bood, udev, networkd, logind, timedated</p>
                <p>TODO</p>
            </section>
            <section>
                <h3>Et maintenant...</h3>
            </section>
        </section>
        <section data-background-color="#6aa84f">
            <section>
            <h1>Travaux Pratiques :</h1>
                <h3 class="fragment" data-fragment-index="0">Création d'un service pour une application node js</h3>
                <video class="fragment" data-fragment-index="0" data-autoplay="" loop="loop" src="img/madscientist.mp4"></video>
            </section>
            <section>
                <h3>Récupération du code et des dépendances</h4>
                <ol>
                    <li class="fragment">Installer git, curl, nodejs, npm et mongodb :
                        <pre><code>sudo apt-get install npm nodejs mongodb curl git</code></pre>
                    </li>
                    <li class="fragment">Cloner le repository git du TP : <pre><code>git clone https://github.com/oknozor/awesome-api</code></pre></li>
                </ol>
            </section>
            <section>
                <h3>Lancement de l'application</h3>
                    <ol>
                        <li class="fragment">Aller dans le répertoire du projet
                            <pre><code>cd awesome-api</code></pre>
                        </li>
                        <li class="fragment">Installer les dépendances de l'application :
                            <pre><code>npm install</code></pre></li>
                        <li class="fragment">Lancer l'application :
                            <pre><code>nodejs server.js</code></pre>
                        </li>
                    </ol>
            </section>
            <section>
                <h3>On vérifie que tout s'est bien passé</h3>
                <ol>
                    <li class="fragment">
                        On fait un appel à l'API :
                        <pre><code>curl -X GET localhost:3000</code></pre>
                    </li>
                    <li class="fragment">
                        Normalement la réponse s'affiche comme suit :
                        <pre><code>
okno@FRL- ~ % curl -X GET localhost:3000
{"message":"Welcome to Greatest Hero of all time application.
Browse your hero collection add more heroes."}%
               </code></pre>
                    </li>
                </ol>
               <small class="fragment"><i class="fas fa-info-circle"></i> Une petite surprise se cache dans la route /heroes</small>
            </section>
            <section>
                <h3>Et systemd dans tout ça ? </h3>
                <ul>
                    <li>Lancer une application à la main ce n'est pas pratique&nbsp! Et si on ferme le terminal l'application s'arrêtera...</li>
                    <li class="fragment">Maintenant que notre service est opérationnel on va donc voir comment le lancer avec <b>systemd</b>.</li>
                    <li class="fragment">Comme on l'a vu dans la présentation <b>systemd</b> gère les processus avec des fichiers de configuration.</li>
                </ul>
            </section>
            <section>
                <h3>Pour commencer on va faire une configuration basique :</h3>
                <ol>
                    <li>
                        Récupérer le chemin de l'application :
                        <pre><code>$ pwd</code></pre>
                    </li>
                    <li>
                        Récupérer le chemin de nodejs :
                        <pre><code>$ which nodejs</code></pre>
                    </li>
                </ol>
            </section>
            <section>
                <ol start="3">
                <li>
                    Éditer le fichier de configuration :
                    <pre><code>$ cd systemd && vim awesome-api.service</code></pre>
                </li>
                <li>
                    Compléter les trous avec les informations récupérées à l'étape précedente :
                        <pre><code>[Service]
ExecStart= // ici on va placer la commande à executer
StandardOutput=syslog  // on redirige les log dans "The journal"
SyslogIdentifier= // un identifiant pour rechercher les logs dans le journal

[Install]
WantedBy=multi-user.target // dépendance à la target multi-user</code></pre>
                </li>
                </ol>
            </section>
             <section>
                <h3>Vous avez terminé?</h3>
                <p class="fragment">Voilà à quoi ça ressemble chez nous :</p>
                <pre class="fragment"><code>[Service]
ExecStart=/usr/bin/node /home/okno/public_html/express-api/server.js
StandardOutput=syslog 
SyslogIdentifier=awesome-api
    
[Install] 
WantedBy=multi-user.target</code></pre>
                <small class="fragment">Au fait je vous ai dis que j'utilisais <b>Arch linux</b>?</small>
            </section>
            <section data-background-color="black">
                <video class="stretch" loop="loop" data-autoplay="" src="img/arch.mp4"></video>
            </section>
            <section>
                <h3>Copie du fichier de configuration et lancement de la base de données :</h3>
                <ol>
                    <li class="fragment">On va copier notre fichier de configuration dans le path de systemd :
                    <pre><code>$ sudo cp maconfig /etc/systemd/system/awesome-api.service </code></pre></li>
                    <li class="fragment">
                        Lancement de mongodb (via systemd) :
                        <pre><code>$ sudo systemctl mongodb.service</code></pre>
                    </li>
                </ol>
            </section>
            <section>
                <h3>Vous êtes prêt à lancer votre premier service avec systemd?</h3>
                <p class="fragment" data-fragment-index="0">La joie vous inonde?</p>
                <pre class="fragment" data-fragment-index="1"><code>$ sudo systemctl start awesome-api.service</code></pre>
                <h4 class="fragment" data-fragment-index="2">Vous pouvez maintenant faire un appel sur l'api!</h4>
                <video class="fragment" data-fragment-index="2" data-autoplay="" loop="loop" src="img/joy.mp4"></video>
            </section>
            <section>
                <h3>Les dépendances</h3>
                <p class="fragment">C'est pas mal ! </p>
                    <p class="fragment">Mais si mongodb n'est pas disponible quand on lance le service voila ce qui arrive :
                <pre class="fragment"><code>$ sudo systemctl stop mongodb.service
$ sudo systemctl restart awesome-api.service
$ sudo systemctl status awesome-api.service
Feb 10 12:56:02 FRL- systemd[1]: Started awesome-api.service.
Feb 10 12:56:03 FRL- awesome-api[19555]:
Server is listening on port 3000
Feb 10 12:56:03 FRL- awesome-api[19555]:
Could not connect to the database. Exiting now...
</code></pre>
            </section>
            <section>
                <h3> Pour règler le problème, rien de plus simple :</h3>
                <p class="fragment">On va modifier la configuration de notre service :</p>
               <pre class="fragment"><code>[Unit]
Description=My Awesome API // Une description du service pour le fun
Wants=mongodb.service      // Ici on ajoute la dépendance à mongo

[Service] 
ExecStart=/usr/bin/node /home/okno/public_html/express-api/server.js
Restart=always
StandardOutput=syslog 
SyslogIdentifier=heroes-api

[Install] 
WantedBy=multi-user.target</code></pre>
            </section>
            <section>
                <h3> Et voilà le travail ! On va pouvoir tester :</h3>
                <ol>
                <li class="fragment"> On recharge la configuration :
                    <pre><code>$ sudo systemctl daemon-reload</code></pre>
                </li>
                <li class="fragment">On arrête mongodb :
                    <pre><code>$ sudo systemctl stop mongodb</code></pre>
                </li>
                <li class="fragment">On lance l'application :
                    <pre><code>$ sudo systemctl start awesome-api.service</code></pre>
                </li>
                <li class="fragment">On teste l'API :
                    <pre><code>$ curl -X GET localhost:3000/heroes</code></pre>
                </li>
                </ol>
                <small class="fragment"><i class="fas fa-info-circle"></i> Ça marche ! Systemd s'est chargé de lancer mongodb pour nous</small>
            </section>
            <section>
                <h3>Socket d'activation</h3>
                <p class="fragment">Le socket d'activation va nous permettre de lancer automatiquement le service à chaque fois qu'on fait un appel sur le port 3000. </p>
                <img class="fragment" style="opacity: 50%; border: none; padding: 10px" src="img/socket_diagram.png" style="background: none; border:0ch; padding: 2ch">
            </section>
            <section>
                <ol>
                    <li>
                        On se place dans le dossier de systemd :
                        <pre><code>$ cd /etc/systemd/system/</code></pre>
                    </li>
                    <li class="fragment">
                        On édite le fichier de configuration pour le socket :
                        <pre><code>$ vim awesome-api.socket</code></pre> 
                    </li>
                    <li class="fragment">Dans lequel on insert les lignes suivantes :
                        <pre><code>[Socket]
ListenStream=3000

[Install]
WantedBy=sockets.target</code></pre></li>
                </ol>
            </section>
            <section>
                <p>On va éditer le service pour qu'il ne redémarre plus automatiquement :</p>
                <pre class="fragment"><code>[Unit]
Description= My awesome API
Wants= mongodb.service

// On a supprimé la ligne Restart=always
[Service] 
ExecStart=/usr/bin/node /home/okno/public_html/express-api/server.js
StandardOutput=syslog 
SyslogIdentifier=awesome-api-socket

[Install]
WantedBy=multi-user.target</code></pre>
                <p class="fragment">Il va maintenant être activé sur demande par le socket.</p>
    </section>
    <section>
        <ol>
            <li class="fragment">
                <p>On se replace dans le path du projet git puis on change de branche : </p>
                <pre><code>$ git checkout socket
$ npm install</code></pre>
            </li>
            <li class="fragment">
                <p>On stoppe tous les services et on recharge la configuration :</p> 
                <pre><code>$ sudo systemctl stop mongodb
$ sudo systemctl stop awesome-api.service
$ sudo systemctl daemon-reload</code></pre>
            </li>
            <li class="fragment">
                <p>En avant pour le socket! </p>
                <pre><code>$ sudo systemctl start awesome-api.socket</code></pre>
            </li>
        </ol>
       <small class="fragment"><i class="fas fa-info-circle"></i> On peut maintenant faire des appels sur l'api.</small> 
    </section>
    <section>
        <h3> Standing ovation!</h3>
        <img src="img/applause.gif">
    </section>
</section>
<section data-background-color="#8e7cc3"><h1>Questions ?</h1></section>
<section data-background-color="#8e7cc3">
    <img class="stretch" src="img/thatsall.gif">
</section>
</div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
// More info about config & dependencies:
// - https://github.com/hakimel/reveal.js#configuration
// - https://github.com/hakimel/reveal.js#dependencies
Reveal.initialize({
dependencies: [
{src: 'plugin/markdown/marked.js'},
{src: 'plugin/markdown/markdown.js'},
{src: 'plugin/notes/notes.js', async: true},
{
src: 'plugin/highlight/highlight.js', async: true, callback: function () {
    hljs.initHighlightingOnLoad();
}
}
]
});

Reveal.configure({
slideNumber: 'c/t',
history: 'true'
});
</script>
</body>
</html>
